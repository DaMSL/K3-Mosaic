/* Further investigation of correctives */

foreign hash_int : int -> int
foreign hash_addr : address -> int
foreign int_of_float : float -> int
foreign float_of_int : int -> float
foreign get_max_int : unit -> int
foreign divf : (float, float) -> float
foreign mod : (int, int) -> int

declare vid_lt : ((int, int, int), (int, int, int)) -> bool =
  \((l0:int, l1:int, l2:int), (r0:int, r1:int, r2:int)) ->
    l0 < r0 | (l0 == r0 & (l1 < r1 | (l1 == r1 & l2 < r2)))

declare vid_eq : ((int, int, int), (int, int, int)) -> bool =
  \((l0:int, l1:int, l2:int), (r0:int, r1:int, r2:int)) ->
    l0 == r0 & (l1 == r1 & l2 == r2)

declare vid_gt : ((int, int, int), (int, int, int)) -> bool =
  \((l0:int, l1:int, l2:int), (r0:int, r1:int, r2:int)) ->
    l0 > r0 | (l0 == r0 & (l1 > r1 | (l1 == r1 & l2 > r2)))

declare __SQL_SUM_AGGREGATE_1_mR1 : {((int, int, int), int, int)} = 
  {((0, 4, 701187881), 4, 5); ((0, 6, 701187881), 3, 1); ((1, 5, 701187881), 2, 4)}

declare __SQL_SUM_AGGREGATE_1 : {((int, int, int), int)} =
  {((0, 2, 701187881), 0); ((1, 5, 701187881), 0); ((0, 4, 701187881), 0); ((1, 3, 701187881), 0); ((1, 1, 701187881), 0); ((0, 0, 68542151), 0)}

declare add_delta_to___SQL_SUM_AGGREGATE_1 :
  ((int, int, int), {(int, int, int), int}) -> unit =
  \(min_vid:(int, int, int), delta_tuples:{(int, int, int), int}) ->
    do {
      let existing_out_tier:{|(int, int, int), int|} = __SQL_SUM_AGGREGATE_1 in
      iterate
        (\(vid:(int, int, int), __prod_ret__1:int) ->
             let update_value:int =
               peek(let (__1:{int}, __2:(int, int, int)) =
                      fold
                        (\((acc:{int}, max_vid:(int, int, int)), 
                          (map_vid:(int, int, int), __map_val:int)) ->
                             if vid_lt(map_vid, vid)
                             then
                               if vid_eq(map_vid, max_vid)
                               then ({__map_val}++acc, max_vid)
                               else
                                 if vid_gt(map_vid, max_vid)
                                 then ({__map_val}, map_vid)
                                 else (acc, max_vid)
                             else (acc, max_vid),
                        ({} : {int}, (0, 0, 0)),
                        existing_out_tier) in __1) + __prod_ret__1 in do {
               insert(__SQL_SUM_AGGREGATE_1, vid, update_value) },
        delta_tuples);
      iterate
        (\(vid_arg:(int, int, int), __arg_val:int) ->
             iterate
               (\(vid:(int, int, int), __map_val:int) ->
                    update(__SQL_SUM_AGGREGATE_1,
                      (vid, __map_val),
                      (vid, __map_val + __arg_val)),
               filtermap(\(vid:(int, int, int), __map_val:int) -> vid > min_vid,
                 \(__id_0:(int, int, int), __id_1:int) -> (__id_0, __id_1),
                 __SQL_SUM_AGGREGATE_1[_, _])),
        delta_tuples)
      }

declare insert_R_do_corrective_s8_m___SQL_SUM_AGGREGATE_1_mR1 :
  ((int, int, int), int, int, {((int, int, int), int, int)}) -> unit =
    \(vid:(int, int, int), R_A:int, R_B:int, delta_tuples:{(int, int, int), int, int}) ->
  iterate
    (\(_, delta___SQL_SUM_AGGREGATE_1_mRR_B:int, 
      delta___SQL_SUM_AGGREGATE_1_mR1:int) ->
         let existing_out_tier:{(int, int, int), int} = __SQL_SUM_AGGREGATE_1 in
         let __prod_ret__16:int =
           ((if R_B == delta___SQL_SUM_AGGREGATE_1_mRR_B then 1 else 0) *
           delta___SQL_SUM_AGGREGATE_1_mR1) * R_A in do {
           add_delta_to___SQL_SUM_AGGREGATE_1(vid, {vid, __prod_ret__16}) },
    delta_tuples)

declare calc : unit = insert_R_do_corrective_s8_m___SQL_SUM_AGGREGATE_1_mR1(
    (1, 1, 701187881), 1, 3, {|((0,6,701187881), 3, 1);((0,6,701187881), 3, 1)|}
)

trigger on_init(x:int) {} = do {
  ()
}

role dummy {
  source s_on_init : (int) = stream([1])
  bind s_on_init -> on_init
  consume s_on_init
}

default role dummy
