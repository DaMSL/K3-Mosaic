/* Now we test shuffle */
foreign hash_int : int -> int
foreign hash_addr : address -> int
foreign int_of_float : float -> int
foreign float_of_int : int -> float
foreign get_max_int : unit -> int
foreign divf : (float, float) -> float
foreign mod : (int, int) -> int

declare pmap_data : [int, [int, int]] = [3, [0, 8; 1, 4]; 2, [0, 32]; 5, [0, 
  32]; 4, [0, 32]; 6, [0, 32]]

declare replicas : ref {int} = {8}

declare set_replicas : int -> unit = \n:int ->
    update(replicas, peek(replicas), n)

declare my_peers : {address, string, string} = 
  {(0.0.0.0:10, "node", ""); (1.1.1.1:10, "node", "")}

declare node_ring : ref [address, string, string, int]

declare add_node : (address, string, string) -> unit =
  \(addr:address, _role_:string, name:string) ->
    let rng:[int] = [1:1:peek(replicas[_])] in
    let new_elems:ref {address, string, string, int} =
      map(\i:int -> (addr, _role_, name, hash_int(i + hash_addr(addr))), rng) in
    do {
      iterate
        (\x:(address, string, string, int) -> insert(node_ring, x),
        new_elems);
      let temp_ring:ref [address, string, string, int] = sort(node_ring,
        \((addr:address, _role_:string, name:string, hash1:int), 
         (addr:address, _role_:string, name:string, hash2:int)) ->
          hash1 > hash2) in
      do {
        iterate
          (\node:(address, string, string, int) -> delete(node_ring, node),
          node_ring);
        iterate
          (\node:(address, string, string, int) -> insert(node_ring, node),
          temp_ring)
        }
      }


/* dummy to add peers to node ring */
declare x : unit =
  iterate
    (\(addr:address, _role_:string, name:string) ->
         if _role_ != "switch" then add_node(addr, _role_, name) else (),
    my_peers)

declare remove_node : (address, string, string) -> unit =
  \(addr:address, _role_:string, name:string) ->
    let nodes_to_delete:ref {address, string, string, int} = node_ring[addr, 
      _role_, name, _] in
    iterate
      (\x:(address, string, string, int) -> delete(node_ring, x),
      nodes_to_delete)

declare get_ring_node : (int, int) -> address = \(data:int, max_val:int) ->
    let scaled:int =
      int_of_float(float_of_int(get_max_int(())) *
        divf(float_of_int(data), float_of_int(max_val))) in
    let results:ref {address, string, string, int} =
      filtermap(\(addr:address, _role_:string, name:string, hash:int) ->
                    hash >= scaled,
        \(__id_0:address, __id_1:string, __id_2:string, __id_3:int) ->
            (__id_0, __id_1, __id_2, __id_3),
        node_ring) in
    let (addr:address, _, _, _) =
      if results == {} : ref {address, string, string, int}
      then peek(node_ring)
      else peek(results) in addr

declare get_ring_val : (int, int) -> int = \(data:int, max_val:int) ->
    let scaled:int =
      int_of_float(float_of_int(get_max_int(())) *
        divf(float_of_int(data), float_of_int(max_val))) in
    scaled

declare get_all_nodes : unit -> [address] = \_ ->
    map
      (\(addr:address, _role_:string, name:string, hash:int) -> addr,
      node_ring)

declare calc_dim_bounds : [int, int] -> ([int, int], int) = \pmap:[int, int] ->
    fold
      (\((xs:[int, int], acc_size:int), (pos:int, bin_size:int)) ->
           (xs++[pos, acc_size], bin_size * acc_size),
      ([] : [int, int], 1),
      pmap)

declare route_to_ATIMESD_mR1 : maybe int -> {|address|} = \key:maybe int ->
    let pmap:[int, int] =
      let (__fst:int, __snd:[int, int]) = peek(pmap_data[6, _]) in __snd in
    if pmap == [] : [int, int]
    then get_all_nodes(())
    else let (dim_bounds:[int, int], max_val:int) = calc_dim_bounds(pmap) in
      let key_id_0:maybe int = key in
      let bound_bucket:int =
        (if key_id_0 == nothing: maybe int
         then 0
         else let pmap_slice:[int, int] = pmap[0, _] in
           if pmap_slice == [] : [int, int]
           then 0
           else let just key_id_0_unwrap:int = key_id_0 in
             let value:int =
               mod(hash_int(key_id_0_unwrap), 
                 let (__fst:int, __snd:int) = peek(pmap_slice) in __snd) in
             value * let (__fst:int, __snd:int) = peek(dim_bounds[0, _]) in
             __snd) + 0 in
      let free_dims:[int, int] =
        (if key_id_0 != nothing: maybe int then [] : [int, int] else pmap[0, _])
        ++[] : [int, int] in
      let free_domains:[int, [int]] =
        map(\(i:int, b_i:int) -> (i, [0:1:b_i + -1]), free_dims) in
      let free_cart_prod:[[int, int]] =
        fold
          (\(prev_cart_prod:[[int, int]], (i:int, domain:[int])) ->
               flatten
                 (map
                    (\domain_element:int ->
                         if prev_cart_prod == [] : [[int, int]]
                         then [[i, domain_element]]
                         else
                           map
                             (\rest_tup:[int, int] ->
                                  rest_tup++[i, domain_element],
                             prev_cart_prod),
                    domain)),
          [] : [[int, int]],
          free_domains) in
      let sorted_ip_list:[address, [address]] =
        groupby(\ip:address -> ip,
          \(acc:[address], ip:address) -> [ip]++acc,
          [] : [address],
          map
            (\free_bucket:[int, int] ->
                 get_ring_node
                   (fold
                      (\(acc:int, (i:int, val:int)) ->
                           acc + (val *
                           let (__fst:int, __snd:int) = peek(dim_bounds[i, _]) in
                           __fst),
                      bound_bucket,
                      free_bucket), max_val),
            free_cart_prod)) in
      if sorted_ip_list == [] : [address, [address]]
      then [get_ring_node(bound_bucket, max_val)]
      else map(\(__fst:address, __snd:[address]) -> __fst, sorted_ip_list)

declare shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0 :
  (maybe int, {|(int, int, int), int, int, int|}, bool) -> {|address, {|(int, int, int), int, int, int|}|} =
  \(l_key:maybe int, tuples:{|(int, int, int), int, int, int|}, 
   shuffle_on_empty:bool) ->
    let __id_l0:maybe int = l_key in
    let all_targets:{|address, {|(int, int, int), int, int, int|}|} =
      if shuffle_on_empty == true
      then
        map
          (\ip:address -> (ip, {||} : {|(int, int, int), int, int, int|}),
          route_to_ATIMESD_mR1(l_key))
      else {||} : {|address, {|(int, int, int), int, int, int|}|} in
    groupby(\(ip:address, tuple:{|(int, int, int), int, int, int|}) -> ip,
      \(acc:{|(int, int, int), int, int, int|}, 
       (ip:address, tuple:{|(int, int, int), int, int, int|})) -> tuple++acc,
      {||} : {|(int, int, int), int, int, int|},
      all_targets++
        flatten
          (map
             (\r_tuple:((int, int, int), int, int, int) ->
                  let (__id_r0:(int, int, int), __id_r1:int, __id_r2:int, 
                      __id_r3:int) = r_tuple in
                  let full_lkey:maybe int = just __id_r1 in
                  map
                    (\ip:address -> (ip, {|r_tuple|}),
                    route_to_ATIMESD_mR1(full_lkey)),
             tuples)))

declare shuffle_ATIMESD_mS2_ATIMESD_mR1 :
  (maybe int, {|(int, int, int), int, int|}, bool) -> {|address, {|(int, int, int), int, int|}|} =
  \(l_key:maybe int, tuples:{|(int, int, int), int, int|}, 
   shuffle_on_empty:bool) ->
    let __id_l0:maybe int = l_key in
    let all_targets:{|address, {|(int, int, int), int, int|}|} =
      if shuffle_on_empty == true
      then
        map
          (\ip:address -> (ip, {||} : {|(int, int, int), int, int|}),
          route_to_ATIMESD_mR1(l_key))
      else {||} : {|address, {|(int, int, int), int, int|}|} in
    groupby(\(ip:address, tuple:{|(int, int, int), int, int|}) -> ip,
      \(acc:{|(int, int, int), int, int|}, 
       (ip:address, tuple:{|(int, int, int), int, int|})) -> tuple++acc,
      {||} : {|(int, int, int), int, int|},
      all_targets++
        flatten
          (map
             (\r_tuple:((int, int, int), int, int) ->
                  let (__id_r0:(int, int, int), __id_r1:int, __id_r2:int) =
                    r_tuple in let full_lkey:maybe int = __id_l0 in
                  map
                    (\ip:address -> (ip, {|r_tuple|}),
                    route_to_ATIMESD_mR1(full_lkey)),
             tuples)))

declare result : {|address, {|(int, int, int), int, int, int|}|} = 
  shuffle_ATIMESD_mT1_mR1_ATIMESD_mR1_0t0 ((just 1, {((0, 29, 701187881), 1, 0, 7); ((0, 28, 701187881), 3, 0, 7); ((0, 2, 701187881), 3, 0, 0)}, false))

declare res_dim : ([int, int], int) = calc_dim_bounds([0,2])

declare res_node1 : address = get_ring_node(0,32)
declare res_node2 : address = get_ring_node(1,32)
declare res_node3 : address = get_ring_node(2,32)
declare res_node4 : address = get_ring_node(3,32)
declare res_node5 : address = get_ring_node(4,32)
declare res_node6 : address = get_ring_node(5,32)
declare res_node7 : address = get_ring_node(6,32)
declare res_node8 : address = get_ring_node(7,32)
declare res_node9 : address = get_ring_node(8,32)
declare res_node10 : address = get_ring_node(8,32)
declare res_node11 : address = get_ring_node(10,32)
declare res_node12 : address = get_ring_node(11,32)
declare res_node13 : address = get_ring_node(12,32)
declare res_node14 : address = get_ring_node(13,32)
declare res_node15 : address = get_ring_node(14,32)
declare res_node16 : address = get_ring_node(15,32)
declare res_node17 : address = get_ring_node(16,32)
declare res_node18 : address = get_ring_node(17,32)
declare res_node19 : address = get_ring_node(18,32)
declare res_node20 : address = get_ring_node(19,32)

declare res_nodev3 : int = get_ring_val(0,8)
declare res_nodev4 : int = get_ring_val(1,8)
declare res_nodev5 : int = get_ring_val(2,8)
declare res_nodev6 : int = get_ring_val(3,8)
declare res_nodev7 : int = get_ring_val(4,8)
declare res_nodev8 : int = get_ring_val(5,8)
declare res_nodev9 : int = get_ring_val(6,8)
declare res_nodev10 : int = get_ring_val(7,8)

declare max_i : int = get_max_int(())
  
trigger on_init(x:int) {} = do {
  ()
}

role dummy {
  source s_on_init : (int) = stream([1])
  bind s_on_init -> on_init
  consume s_on_init
}

default role dummy
