// Testing the shuffle functions

foreign hash_int : int -> int
foreign hash_addr : address -> int
foreign int_of_float : float -> int
foreign float_of_int : int -> float
foreign get_max_int : unit -> int
foreign divf : (float, float) -> float
foreign mod : (int, int) -> int

declare node_ring : ref {address, maybe string, int}

declare replicas : ref {int} = {1}

declare set_replicas : int -> unit = \n:int ->
    update(replicas, peek(replicas), n)

declare add_node : (address, maybe string) -> unit =
  \(addr:address, name:maybe string) ->
    let rng:[int] = [1:1:peek(replicas[_])] in
    let new_elems:ref {address, maybe string, int} =
      map(\i:int -> (addr, name, hash_int(i + hash_addr(addr))), rng) in
    iterate(\x:(address, maybe string, int) -> insert(node_ring, x), new_elems)

declare remove_node : (address, maybe string) -> unit =
  \(addr:address, name:maybe string) ->
    let nodes_to_delete:ref {address, maybe string, int} = node_ring[addr, 
      name, _] in
    iterate
      (\x:(address, maybe string, int) -> delete(node_ring, x),
      nodes_to_delete)

declare get_ring_node : (int, int) -> address = \(data:int, max_val:int) ->
    let scaled:int =
      int_of_float(float_of_int(get_max_int(())) *
        divf(float_of_int(data), float_of_int(max_val))) in
    let results:ref {address, maybe string, int} =
      filtermap(\(addr:address, name:maybe string, hash:int) -> hash >= scaled,
        \(__id_0:address, __id_1:maybe string, __id_2:int) ->
            (__id_0, __id_1, __id_2),
        node_ring) in
    let (addr:address, _, _) =
      if results == {} : ref {address, maybe string, int}
      then peek(node_ring)
      else peek(results) in addr

declare get_all_nodes : unit -> [address] = \_ ->
    map(\(addr:address, _, _) -> addr, node_ring)

declare pmap_data : [int, [int, int]] = [0, [] : [int, int]; 1, [] :
  [int, int]; 2, [] : [int, int]; 3, [] : [int, int]]

declare calc_dim_bounds : [int, int] -> ([int, int], int) = \pmap:[int, int] ->
    fold
      (\((xs:[int, int], acc_size:int), (pos:int, bin_size:int)) ->
           (xs++[pos, acc_size], bin_size * acc_size),
      ([] : [int, int], 1),
      pmap)

declare route_to___SQL_SUM_AGGREGATE_1 : maybe int -> {address} =
  \key:maybe int ->
    let pmap:[int, int] =
      let (__fst:int, __snd:[int, int]) = peek(pmap_data[1, _]) in __snd in
    if pmap == [] : [int, int]
    then get_all_nodes(())
    else let (dim_bounds:[int, int], max_val:int) = calc_dim_bounds(pmap) in
      let key_id_0:maybe int = key in
      let bound_bucket:int =
        (if key_id_0 == nothing: maybe int
         then 0
         else let pmap_slice:[int, int] = pmap[0, _] in
           if pmap_slice == [] : [int, int]
           then 0
           else let just key_id_0_unwrap:int = key_id_0 in
             let value:int =
               mod(hash_int(key_id_0_unwrap), 
                 let (__fst:int, __snd:int) = peek(pmap_slice) in __snd) in
             value * let (__fst:int, __snd:int) = peek(dim_bounds[0, _]) in
             __snd) + 0 in
      let free_dims:[int, int] =
        (if key_id_0 != nothing: maybe int then [] : [int, int] else pmap[0, _])
        ++[] : [int, int] in
      let free_domains:[int, [int]] =
        map(\(i:int, b_i:int) -> (i, [0:1:b_i + -1]), free_dims) in
      let free_cart_prod:[[int, int]] =
        fold
          (\(prev_cart_prod:[[int, int]], (i:int, domain:[int])) ->
               flatten
                 (map
                    (\domain_element:int ->
                         if prev_cart_prod == [] : [[int, int]]
                         then [[i, domain_element]]
                         else
                           map
                             (\rest_tup:[int, int] ->
                                  rest_tup++[i, domain_element],
                             prev_cart_prod),
                    domain)),
          [] : [[int, int]],
          free_domains) in
      let sorted_ip_list:[address, [address]] =
        groupby(\ip:address -> ip,
          \(acc:[address], ip:address) -> [ip]++acc,
          [] : [address],
          map
            (\free_bucket:[int, int] ->
                 get_ring_node
                   (fold
                      (\(acc:int, (i:int, val:int)) ->
                           acc + (val *
                           let (__fst:int, __snd:int) = peek(dim_bounds[i, _]) in
                           __fst),
                      bound_bucket,
                      free_bucket), max_val),
            free_cart_prod)) in
      if sorted_ip_list == [] : [address, [address]]
      then [get_ring_node(bound_bucket, max_val)]
      else map(\(__fst:address, __snd:[address]) -> __fst, sorted_ip_list)


declare shuffle___SQL_SUM_AGGREGATE_1_mR6___SQL_SUM_AGGREGATE_1_0t0 :
  (maybe int, {(int, int, int), int, int}, bool) -> {address, {(int, int, int), int, int}} =
  \(l_key:maybe int, tuples:{(int, int, int), int, int}, shuffle_on_empty:bool) ->
    let __id_l0:maybe int = l_key in
    let all_targets:{address, {(int, int, int), int, int}} =
      if shuffle_on_empty == true
      then
        map
          (\ip:address -> (ip, {} : {(int, int, int), int, int}),
          route_to___SQL_SUM_AGGREGATE_1(l_key))
      else {} : {address, {(int, int, int), int, int}} in
    groupby(\(ip:address, tuple:{(int, int, int), int, int}) -> ip,
      \(acc:{(int, int, int), int, int}, 
       (ip:address, tuple:{(int, int, int), int, int})) -> tuple++acc,
      {} : {(int, int, int), int, int},
      all_targets++
        flatten
          (map
             (\r_tuple:((int, int, int), int, int) ->
                  let (__id_r0:(int, int, int), __id_r1:int, __id_r2:int) =
                    r_tuple in let full_lkey:maybe int = just __id_r1 in
                  map
                    (\ip:address -> (ip, {r_tuple}),
                    route_to___SQL_SUM_AGGREGATE_1(full_lkey)),
             tuples)))

declare result : {address, {(int, int, int), int, int}} = 
    {} : {address, {(int, int, int), int, int}}

trigger on_init(x:int) {} = do {
  iterate(\(addr:address, name:maybe string) -> add_node(addr, name), peers);
  iterate(\r:(address, {((int, int, int), int, int)}) -> insert(result, r),
    shuffle___SQL_SUM_AGGREGATE_1_mR6___SQL_SUM_AGGREGATE_1_0t0(
      (just 3, {} : {(int, int, int), int, int}, true)))
}

role switch {
  source s_on_init : int = stream([1])
  bind s_on_init -> on_init
  consume s_on_init
}

default role switch
