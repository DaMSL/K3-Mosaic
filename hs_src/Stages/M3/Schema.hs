module Stages.M3.Schema where
-- Typechecks
-- Global definitions for the schema of a database/set of streams

import Network.Socket as Net
import Data.Char (toUpper)
import Data.List as L

import Stages.M3.M3Type
import Stages.M3.ListExtras (elem_assoc, remove_assoc)
import qualified Stages.M3.ListExtras as LE
import qualified Stages.M3.Debug as Debug

--- Typing metadata for relations
data RelType = StreamRel           -- Dynamic relation.  The standard for DBT
   | TableRel            -- Static relation; DBT does not generate update 
                         --    triggers for Tables
     deriving (Show, Eq)
                

-- A Relation definition:: Consists of [name] x [schema] x [typing metadata]
type Rel = (String, [Var], RelType)

-- A triggered event --
data Event = InsertEvent Rel    -- An insertion into the specified relation
 | DeleteEvent Rel    -- A deletion from the specified relation
 | CorrectiveUpdate String [Var] [Var] Var Event
                    {- (For distributed execution) A correction to a
                        an external -- The fields of the event are:: 
                           * External Name
                           * Input Vars (trigger parameter)
                           * Output Vars (trigger parameter)
                           * Value Var (trigger parameter)
                           * Event being corrected (also specifies parameters)
                        (see the [DistributedM3] module for details on this 
                        event) -}
 | SystemInitializedEvent  -- Invoked when the system has been initialized, 
                           --   once all static tables have been loaded.
   deriving (Show, Eq)

-- Tuple framing constructs for data sources. --
data Framing = Delimited String -- Tuple frames are delimited by this string
   | FixedSize Int    -- Tuple frames are of fixed size
     deriving (Show, Eq)

-- Data source constructs
data Source =  NoSource               -- The nullary data source.
   | FileSource String Framing        -- Read data from a file with the 
                                      -- specified framing construct
   | PipeSource String Framing        -- Read data from a UNIX pipe with the
                                      -- specified framing construct
   | SocketSource Net.HostAddress Int Framing 
     deriving (Show, Eq)
                                      -- Create a server on the specified 
                                      -- address and port, and read data from
                                      -- client sockets on that port with the
                                      -- specified framing construct

{-
   An Adaptor, or mechanism for parsing tuple frames into data.  Adaptors 
   consist of a string name, and a list of string key/value pairs 
   parameterizing the adaptor.
-}
type Adaptor = (String, [(String, String)])

{-
   Schema information for a given source.  For each source, a list of all 
   adaptors connected to that source, and the relation generated by that 
   adaptor.
-}
type SourceInfo = (Source, [(Adaptor, Rel)])

{-
   A database schema.  A list of all sources used by the engine.  Referential, 
   so it can be built up incrementally.
-}
type T = [SourceInfo]

{-
   An instance of the default empty database schema.
-}
empty_db :: () -> T
empty_db () = []

{-
   Add a relation to the indicated database schema.  Optionally include the 
   source and adaptor that will read into the relation.
   ++param db      The database schema to modify
   ++param source  (optional) The source from which the relation's tuples will 
                  be read.
   ++param adaptor (optional) The adaptor that will parse the relation's tuples
   ++param rel     The relation to add to the schema
-}

add_rel = add_rel_full NoSource ("",[])

add_rel_full :: Source -> Adaptor -> T -> Rel -> T
add_rel_full source adaptor db rel = 
   case lookup source db of
     Nothing          -> (source, [(adaptor, rel)]) : db
     Just source_rels -> 
       (source, (adaptor, rel):source_rels) : (remove_assoc source db)

{-
   Obtain the relations appearing in the indicated database schema.
   ++param db   The database schema
   ++return     A list of all relations appearing in [db]
-}
rels :: T -> [Rel]
rels db = L.foldl' (\old (_, rels) -> old++map snd rels) [] db

{-
   Obtain the static (table) relations appearing in the indicated database 
   schema
   ++param db   The database schema
   ++return     A list of all static (table) relations appearing in [db]
-}
table_rels :: T -> [Rel]
table_rels db = L.filter (\(_,_,rt) -> rt == TableRel) $ rels db

{-
   Obtain the dynamic (stream) relations appearing in the indicated database 
   schema
   ++param db   The database schema
   ++return     A list of all dynamic (stream) relations appearing in [db]
-}
stream_rels :: T -> [Rel]
stream_rels db = L.filter (\(_,_,rt) -> rt == StreamRel) $ rels db

{-
   Obtain the full relation object for a given relation name in the indicated
   database schema
   ++param db   The database schema
   ++param reln The name of a relation
   ++return     The [rel_t] object for the relation named [reln] in [db]
   ++raise Not_found If no relation named [reln] appears in [db]
-}
rel :: T -> String -> Maybe Rel
rel db reln = L.find (\(cmpn,_,_) -> reln == cmpn) $ rels db

{-
   Partition the sources in a database schema by type of relation they 
   generate. All the sources that generate stream relations will be grouped 
   together and all the sources that generate table relations will be grouped
   together. Sources that generate both will be included in both groups, but
   each [source_info_t] will contain only the appropriate relations.
   
   ++param db   The database schema
   ++return     A pair (table_sources, stream_sources) of [source_info_t]s 
               containing every source in [db], grouped accordingly
-}
partition_sources_by_type :: T -> ([SourceInfo], [SourceInfo])
partition_sources_by_type db = LE.flatten_list_pair $ map part db
   where 
     part (source, all_rels) =
       let (table_rels, stream_rels) = L.partition 
             (\(_,(_,_,t)) -> t == TableRel) all_rels
           f rel = if null rel then [] else [(source, rel)]
       in (f table_rels, f stream_rels)

{-
   Obtain the parameter list for the indicated event
   ++param event An event
   ++return      A list of all parameters taken by [event]
-}
event_vars :: Event -> [Var]
event_vars event = case event of
  InsertEvent(_, relv, _) -> relv
  DeleteEvent(_, relv, _) -> relv
  CorrectiveUpdate _ ivars ovars vvar updated_evt -> 
                     ivars ++ ovars ++ [vvar] ++ (event_vars updated_evt)
  SystemInitializedEvent -> []

{-
   Variation-aware comparator for events
   ++param a   An event
   ++param b   An event
   ++return    True if [a] and [b] refer to the same event, even if they differ
              on the details of this event.
-}
events_equal :: Event -> Event -> Bool
events_equal a b = case (a,b) of
  (SystemInitializedEvent, SystemInitializedEvent) -> True
  (InsertEvent (an, _, _),  InsertEvent (bn, _, _))     -> an == bn
  (DeleteEvent (an, _, _), DeleteEvent (bn, _, _))      -> an == bn
  (CorrectiveUpdate aen _ _ _ aue, CorrectiveUpdate ben _ _ _ bue) -> 
          aen == ben && events_equal aue bue
  _ -> False

{-
   Generate the human-readable representation of a relation, in the form 
   [RelationName(col1, col2, col3, ...)].
   function is compatible with Calculusparser.
   ++param rel   A relation
   ++return      A human-readable representation of [rel]
-}
string_of_rel :: Rel -> String
string_of_rel (reln, relsch, _) = 
  reln ++ "(" ++ LE.string_of_list_sep ", " string_of_var relsch ++ ")"

{-
   Obtain the name of a relation
   ++param rel   A relation
   ++return      The name of [rel]
-}
name_of_rel :: Rel -> String
name_of_rel (reln,_,_) = reln

{-
   Obtain a whitespace-free identifier usable to describe an event.
-}
name_of_event :: Event -> String
name_of_event event = case event of
  InsertEvent (reln, _, _)   -> "insert_" ++ reln
  DeleteEvent (reln, _, _)   -> "delete_" ++ reln
  CorrectiveUpdate en _ _ _ updated_evt -> "correct_" ++ en ++ "_for_" ++ 
      name_of_event updated_evt
  SystemInitializedEvent -> "system_ready_event"

{-
   Obtain a whitespace-free identifier useable to describe the general type of 
   an event.
-}
class_name_of_event :: Event -> String
class_name_of_event event = case event of
  InsertEvent (_, _, _) -> "insert_tuple"
  DeleteEvent (_, _, _) -> "delete_tuple"
  CorrectiveUpdate en _ _ _ updated_evt -> "corrective_update"
  SystemInitializedEvent -> "system_ready_event"

{-
   Obtain a whitespace-free identifier useable to describe the 'relation' 
   triggering an event.
-}
rel_name_of_event :: Event -> String
rel_name_of_event event = case event of
  InsertEvent (reln, _, _)    -> reln
  DeleteEvent (reln, _, _)    -> reln
  CorrectiveUpdate en _ _ _ _ -> en
  SystemInitializedEvent      -> "NULL_RELATION"

{-
   Obtain the human-readable representation of an event.  The output of this 
   function is compatible with Calculusparser.
-}
string_of_event :: Event -> String
string_of_event event = case event of
  InsertEvent rel       -> "ON + "++ string_of_rel rel
  DeleteEvent rel       -> "ON - "++ string_of_rel rel
  CorrectiveUpdate en eiv eov eval u_evt -> 
      "CORRECT "++ en ++ "[" ++
      LE.string_of_list_sep "," (string_of_var_verbose True) eiv ++
      "][" ++
      LE.string_of_list_sep "," (string_of_var_verbose True) eov ++
      "] += " ++
      string_of_var_verbose True eval ++" FOR "++ string_of_event u_evt
  SystemInitializedEvent -> "ON SYSTEM READY"

{-
   Obtain a string representation of a framing construct constructor compatible 
   with Calculusparser.
   ++param framing  A framing construct
   ++return         The calculusparser-compatible string representation of
                   [framing] (to be used in a relation constructor)
                   
-}
code_of_framing (Delimited "\n") = "LINE DELIMITED"
code_of_framing (Delimited x)    = "'"++x++"' DELIMITED"
code_of_framing (FixedSize i)    = "FIXEDWIDTH "++ show i

{-
   Obtain a string representation of a source construct constructor compatible 
   with Calculusparser.
   ++param source   A source construct
   ++return         The calculusparser-compatible string representation of
                   the constructor for [source] (to be used in a relation
                   constructor)
-}
code_of_source NoSource = ""
code_of_source (FileSource file framing) = 
  "FROM FILE '"++file++"' "++code_of_framing framing
code_of_source (PipeSource file framing) = 
  "FROM PIPE '"++file++"' "++code_of_framing framing
code_of_source (SocketSource addr port framing) =
  "FROM SOCKET '"++ show addr ++ "'" ++ show port++" "++code_of_framing framing

{-
   Obtain a string representation of an adaptor construct constructor 
   compatible with Calculusparser.
   ++param adaptor  An adaptor construct
   ++return         The calculusparser-compatible string representation of
                   the constructor for [adaptor] (to be used in a relation
                   constructor)
-}
code_of_adaptor :: Adaptor -> String
code_of_adaptor (aname, aparams) =
   map toUpper aname ++
      if null aparams
      then if aname /= "" then "()" else ""
      else "("++ LE.string_of_list_sep ", " (\(k,v) -> k ++" ::= '"++ v ++"'") aparams ++")"

{-
   Obtain a string representation of a relation constructor compatible with 
   Calculusparser.
   ++param rel   A relation
   ++return      A calculusparser (and SQL)-compatible string representation of  
                the constructor for [rel], not including any DBToaster-specific
                constructs.
-}
code_of_rel (reln, relv, relt) =
   "CREATE "++
     case relt of
       StreamRel -> "STREAM"
       TableRel  -> "TABLE"
   ++" "++ reln ++"("++
   LE.string_of_list_sep ", " (\(varn,vart) -> varn++" "++ string_of_type vart) relv ++")"

{-
   Obtain a string representation of the full DBToaster-specific constructors 
   for all relations in the specified database schema
   ++param sch  The database schema
   ++return     A calculusparser (and SQL)-compatible string representation of
               the constructors for all the relations in [sch].
-}
code_of_schema :: T -> String
code_of_schema sch =
   LE.string_of_list_sep "\n\n" (\(source, rels) ->
      let source_string = code_of_source source in
         LE.string_of_list_sep "\n\n" (\(adaptor,rel) ->
            code_of_rel rel ++"\n  "++ source_string ++"\n  "++
            code_of_adaptor adaptor ++ ";"
         ) rels
   ) sch

{-
   Obtain a human-readable string representation of the specified database
   schema
   ++param sch  The database schema
   ++return     A human-readable string representation of [sch]
-}
string_of_schema :: T -> String
string_of_schema sch =
   LE.string_of_list_sep "\n" (\(source, rels) -> 
     case source of
       NoSource           -> "Sourceless"
       FileSource file  _ -> file
       PipeSource file  _ -> "| " ++ file
       SocketSource bindaddr port _ -> 
         if bindaddr == Net.iNADDR_ANY then
             "*::"++show port
         else show bindaddr ++ "::" ++ show port
   ++"\n"++
   LE.string_of_list_sep "\n" 
     (\((aname, aparams), (reln, relsch, relt)) ->
         "   "++ reln ++"("++ LE.string_of_list_sep ", " string_of_var relsch++ ")"++
       if Debug.verbose () then
         case relt of
           TableRel  -> " initialized using "
           StreamRel -> " updated using "
       else case relt of
           TableRel  -> " ::= "
           StreamRel -> " << "
       ++ aname ++"("++ 
       LE.string_of_list_sep ", "
         (\(pname,pval) -> pname ++ " ::= '" ++ pval ++"'") aparams
       ++ ")"
     ) rels
   ) sch
